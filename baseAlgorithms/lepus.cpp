 #define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <fstream>
#include<vector>
#include"string"
#include<algorithm>
#include<map>
#include"queue"
#include"stdlib.h"
#include"stdio.h"
using namespace std;
/*Зайчик прыгает по прямой просеке для удобства разделенной на n клеток.
Клетки пронумерованы по порядку натуральными числами от 1 до n. Некоторые клетки заболочены:
если зайчик прыгнет на такую клетку, ему несдобровать. Некоторые другие клетки просеки поросли вксной зеленой травой:
прыгнув на такую клетку, зайчик сможет отдохнуть и подкрепиться.
Зайчик начинает свой путь из клетки с номером 1 и хочет попасть в клетку с номером n, по пути ни разу не провалившись в болото
и скушав как можно больше вкусной зеленой травы. Конструктивные особенности зайчика таковы, что из клетки с номером 
k он может прыгнуть лищь в клетки с номерами k+1, k+3 и k+5.
Выясните, какое максимальное кол-во клеток с такой травой сможет посетить зайчик на своем пути. Если достигнуть конца нет возможности выведите -1.

Пример
4
."".
Ответ 2
Пример 
5
.w"..
Ответ
0
Пример
9
.www.www.
Ответ 
-1	 
 */


int main()
{
    ifstream cin("lepus.in");
    ofstream cout("lepus.out");
    int n;
    cin >> n;
    vector<char> v;
    v.resize(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i];
    }
    vector<int> ans;
    ans.resize(n);
    for (int i = 1; i < n; i++) {
        ans[i] = -10;
        if (v[i] == 'w') {
            ans[i] = -1000000000;
            continue;
        }
        if (i > 0 && ans[i-1]>=0) {
            ans[i] = ans[i - 1];
        }
        if (i > 2 && ans[i - 3] > ans[i]) {
            ans[i] = ans[i - 3];
        }
        if (i > 4 && ans[i - 5] > ans[i]) {
            ans[i] = ans[i - 5];
        }
        if (v[i] == '"' && ans[i]!=-10) {
            ans[i]++;
        }
        if (ans[i] == -10) {
            ans[i] = -1000000000;
        }
    }
    if (ans[n - 1] < 0) {
        cout << -1;
        return 0;
    }
    cout << ans[n -1];
}